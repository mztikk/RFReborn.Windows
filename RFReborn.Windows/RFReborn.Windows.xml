<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RFReborn.Windows</name>
    </assembly>
    <members>
        <member name="T:RFReborn.Windows.Extensions.IRemoteMemoryExtensions">
            <summary>
            Extends <see cref="T:RFReborn.Windows.Memory.IRemoteMemory"/>
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Extensions.IRemoteMemoryExtensions.FindSignature(RFReborn.Windows.Memory.IRemoteMemory,System.String)">
            <summary>
            Searches for a PEiD style string signature inside of the processes main module.
            </summary>
            <param name="remoteMem"><see cref="T:RFReborn.Windows.Memory.IRemoteMemory"/> used to read from the process.</param>
            <param name="signature">PEiD style string signature to search for.</param>
            <returns>The address of the <see cref="T:RFReborn.AoB.Signature"/> if it is found; -1 otherwise</returns>
        </member>
        <member name="M:RFReborn.Windows.Extensions.IRemoteMemoryExtensions.FindSignature(RFReborn.Windows.Memory.IRemoteMemory,RFReborn.AoB.Signature)">
            <summary>
            Searches for a given <see cref="T:RFReborn.AoB.Signature"/> inside of the processes main module.
            </summary>
            <param name="remoteMem"><see cref="T:RFReborn.Windows.Memory.IRemoteMemory"/> used to read from the process.</param>
            <param name="signature">The <see cref="T:RFReborn.AoB.Signature"/> to search for.</param>
            <returns>The address of the <see cref="T:RFReborn.AoB.Signature"/> if it is found; -1 otherwise</returns>
        </member>
        <member name="M:RFReborn.Windows.Extensions.IRemoteMemoryExtensions.FindSignature(RFReborn.Windows.Memory.IRemoteMemory,RFReborn.AoB.Signature,System.Diagnostics.ProcessModule)">
            <summary>
            Searches for a given <see cref="T:RFReborn.AoB.Signature"/> inside of a <see cref="T:System.Diagnostics.ProcessModule"/>.
            </summary>
            <param name="remoteMem"><see cref="T:RFReborn.Windows.Memory.IRemoteMemory"/> used to read from the process.</param>
            <param name="signature">The <see cref="T:RFReborn.AoB.Signature"/> to search for.</param>
            <param name="processModule">The <see cref="T:System.Diagnostics.ProcessModule"/> to search in.</param>
            <returns>The address of the <see cref="T:RFReborn.AoB.Signature"/> if it is found; -1 otherwise</returns>
        </member>
        <member name="T:RFReborn.Windows.Extensions.ProcessExtensions">
            <summary>
            Extends <see cref="T:System.Diagnostics.Process"/>
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Extensions.ProcessExtensions.GetCommandLine(System.Diagnostics.Process)">
            <summary>
            Gets all commandline arguments a process was started with.
            </summary>
            <param name="proc">Process to get arguments from.</param>
            <returns>String of the commandline arguments if successfull, <see cref="F:System.String.Empty"/> otherwise.</returns>
        </member>
        <member name="M:RFReborn.Windows.Extensions.ProcessExtensions.GetModule(System.Diagnostics.Process,System.String)">
            <summary>
            Searches the <see cref="T:System.Diagnostics.ProcessModuleCollection"/> for the specified name.
            </summary>
            <param name="proc"><see cref="T:System.Diagnostics.Process"/> which modules to search</param>
            <param name="moduleName">Module name to search for.</param>
            <returns><see cref="T:System.Diagnostics.ProcessModule"/></returns>
        </member>
        <member name="T:RFReborn.Windows.Input.Keyboard">
            <summary>
                Provides methods to manipulate and generate Keyboard input.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Input.Keyboard.Modifier">
            <summary>
                Modifier Keys.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Input.Keyboard.Modifier.None">
            <summary>
                No modifier.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Input.Keyboard.Modifier.Shift">
            <summary>
                Shift modifier.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Input.Keyboard.Modifier.Ctrl">
            <summary>
                Ctrl modifier.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Input.Keyboard.Modifier.Alt">
            <summary>
                Alt modifier.
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Input.Keyboard.IsExtendedKey(RFReborn.Windows.Native.Enums.VirtualKeyCode)">
            <summary>
                Determines if the <see cref="T:RFReborn.Windows.Native.Enums.VirtualKeyCode" /> is an ExtendedKey
            </summary>
            <param name="keyCode">The key code.</param>
            <returns>true if the key code is an extended key; otherwise, false.</returns>
            <remarks>
                The extended keys consist of the ALT and CTRL keys on the right-hand side of the keyboard; the INS, DEL, HOME, END,
                PAGE UP, PAGE DOWN, and arrow keys in the clusters to the left of the numeric keypad; the NUM LOCK key; the BREAK
                (CTRL+PAUSE) key; the PRINT SCRN key; and the divide (/) and ENTER keys in the numeric keypad.
                See http://msdn.microsoft.com/en-us/library/ms646267(v=vs.85).aspx Section "Extended-Key Flag"
            </remarks>
        </member>
        <member name="M:RFReborn.Windows.Input.Keyboard.VkKeyScan(System.Char)">
            <summary>
                Translates a char to a virtual key code and modifier.
            </summary>
            <param name="ch">
                Char to translate.
            </param>
            <returns>Virtual key code of the car and the modifier needed.</returns>
        </member>
        <member name="M:RFReborn.Windows.Input.Keyboard.PostMessageKeyDown(System.IntPtr,RFReborn.Windows.Native.Enums.VirtualKeyCode)">
            <summary>
                Posts a WM_KEYDOWN message with a virtual key to a window using PostMessage.
            </summary>
            <param name="hWnd">
                Handle of the window.
            </param>
            <param name="vkCode">
                Key to send down.
            </param>
        </member>
        <member name="M:RFReborn.Windows.Input.Keyboard.PostMessageKeyUp(System.IntPtr,RFReborn.Windows.Native.Enums.VirtualKeyCode)">
            <summary>
                Posts a WM_KEYUP message with a virtual key to a window using PostMessage.
            </summary>
            <param name="hWnd">
                Handle of the window.
            </param>
            <param name="vkCode">
                Key to send up.
            </param>
        </member>
        <member name="M:RFReborn.Windows.Input.Keyboard.PostMessageKeyPress(System.IntPtr,RFReborn.Windows.Native.Enums.VirtualKeyCode,System.Int32)">
            <summary>
                Posts a WM_KEYDOWN followed by a WM_KEYUP message after the delay, with the virtual key to the window using
                PostMessage.
            </summary>
            <param name="hWnd">
                Handle of the window.
            </param>
            <param name="vkCode">
                Key to press-
            </param>
            <param name="delay">
                Delay between WM_KEYDOWN and WM_KEYUP message. Default is 5
            </param>
        </member>
        <member name="M:RFReborn.Windows.Input.Keyboard.PostMessageString(System.IntPtr,System.String,System.Int32)">
            <summary>
                Sends a string(every char in a string) to the window using PostMessage.
            </summary>
            <param name="hWnd">
                Handle of the window.
            </param>
            <param name="textToSend">
                String to send,
            </param>
            <param name="delay">
                Delay between each PostMessage call.
            </param>
        </member>
        <member name="T:RFReborn.Windows.Memory.IRemoteMemory">
            <summary>
            Provides methods to interact with the memory of a remote process.
            </summary>
        </member>
        <member name="P:RFReborn.Windows.Memory.IRemoteMemory.NativeProcess">
            <summary>
            The native process we're interacting with.
            </summary>
        </member>
        <member name="P:RFReborn.Windows.Memory.IRemoteMemory.ProcessHandle">
            <summary>
            Handle to the process.
            </summary>
        </member>
        <member name="P:RFReborn.Windows.Memory.IRemoteMemory.MainModule">
            <summary>
            Main module of the process.
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.GetAddress(System.IntPtr,System.Int32[])">
            <summary>
            Walks a pointer(base + offsets) and returns the final address.
            </summary>
            <param name="address">BaseAddress</param>
            <param name="offsets">Offsets to walk</param>
            <returns>The final address of the pointer.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.ToAbsolute(System.IntPtr)">
            <summary>
            Converts a relative address to an absolute one.
            </summary>
            <param name="address">Relative address.</param>
            <returns>Absolute address</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.Read``1(System.IntPtr,System.Boolean)">
            <summary>
            Reads a valu of type <typeparamref name="T"/> from the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="address">Address where to read the value from.</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>Value read from the remote memory.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.Read``1(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Reads an array of values of type <typeparamref name="T"/> from the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="address">Address where to read the values from.</param>
            <param name="count">Number of values to read, size of the return array.</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>Array of values read from the remote memory.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.ReadString(System.IntPtr,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Reads a string in the remote process memory.
            </summary>
            <param name="address">Address of the values.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to use to get the bytes from the string.</param>
            <param name="maxLength">Maximum length of the string(bytes to be read).</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>String at the address.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.ReadString(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Reads a string with a default <see cref="T:System.Text.Encoding"/> in the remote process memory.
            </summary>
            <param name="address">Address of the values.</param>
            <param name="maxLength">Maximum length of the string(bytes to be read).</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>String at the address.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.Write``1(System.IntPtr,``0,System.Boolean)">
            <summary>
            Writes the value of type <typeparamref name="T"/> to the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="address">Address where to write the value to.</param>
            <param name="value">Value to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.Write``1(System.IntPtr,``0[],System.Boolean)">
            <summary>
            Writes the array of values of type <typeparamref name="T"/> to the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="address">Address where to write the values to.</param>
            <param name="values">Values to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.WriteString(System.IntPtr,System.String,System.Boolean)">
            <summary>
            Writes a string, using a default <see cref="T:System.Text.Encoding"/>, to the remote process at a specified address.
            </summary>
            <param name="address">Address where to write the string to.</param>
            <param name="text">String to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.WriteString(System.IntPtr,System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Writes a string, using the specified <paramref name="encoding"/>, to the remote process at a specified address.
            </summary>
            <param name="address">Address where to write the string to.</param>
            <param name="text">String to write.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to use to get the bytes from the string.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.ReadBytes(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Reads bytes from the remote process at a specified address.
            </summary>
            <param name="address">Address where to read the bytes from.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>Array of size <paramref name="count"/> with the bytes read.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.WriteBytes(System.IntPtr,System.Byte[],System.Boolean)">
            <summary>
            Writes bytes to the remote process at a specified address.
            </summary>
            <param name="address">Address where to write the bytes to.</param>
            <param name="bytes">Bytes to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.Free(System.IntPtr)">
            <summary>
            Frees allocated memory(ex with <see cref="M:RFReborn.Windows.Memory.IRemoteMemory.Alloc(System.Int32,RFReborn.Windows.Native.Enums.MemoryProtection)"/>
            </summary>
            <param name="address">Address of the allocated memory to free.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.IRemoteMemory.Alloc(System.Int32,RFReborn.Windows.Native.Enums.MemoryProtection)">
            <summary>
            Allocates memory in the remote process and returns the address of it.
            </summary>
            <param name="size">Size of memory to allocate.</param>
            <param name="protFlags">Protection flags of the newly allocated memory. Default is <see cref="F:RFReborn.Windows.Native.Enums.MemoryProtection.EXECUTE_READWRITE"/></param>
            <returns>The address to the allocated memory.</returns>
        </member>
        <member name="T:RFReborn.Windows.Memory.RemoteMemory">
            <summary>
            Implementation of <see cref="T:RFReborn.Windows.Memory.IRemoteMemory"/>
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Memory.RemoteMemory.Self64">
            <summary>
            If our process is 64Bit or not.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Memory.RemoteMemory.Both64">
            <summary>
            If our and the process we attached to is 64Bit.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Memory.RemoteMemory.Is64">
            <summary>
            If the process we attached to is 64Bit or not.
            </summary>
        </member>
        <member name="P:RFReborn.Windows.Memory.RemoteMemory.NativeProcess">
            <summary>
            The native process we're interacting with.
            </summary>
        </member>
        <member name="P:RFReborn.Windows.Memory.RemoteMemory.ProcessHandle">
            <summary>
            Handle to the process.
            </summary>
        </member>
        <member name="P:RFReborn.Windows.Memory.RemoteMemory.MainModule">
            <summary>
            Main module of the process.
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.#ctor(System.Diagnostics.Process)">
            <summary>
            Initializes a new instance of <see cref="T:RFReborn.Windows.Memory.RemoteMemory"/>.
            </summary>
            <param name="proc"><see cref="T:System.Diagnostics.Process"/> to open.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Read``1(System.IntPtr,System.Boolean)">
            <summary>
            Reads a value of type <typeparamref name="T" /> from the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="address">Address where to read the value from.</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>Value read from the remote memory.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Read``1(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Reads an array of values of type <typeparamref name="T" /> from the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="address">Address where to read the values from.</param>
            <param name="count">Number of values to read, size of the return array.</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>Array of values read from the remote memory.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Write``1(System.IntPtr,``0,System.Boolean)">
            <summary>
            Writes the value of type <typeparamref name="T" /> to the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of value.</typeparam>
            <param name="address">Address where to write the value to.</param>
            <param name="value">Value to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Write``1(System.IntPtr,``0[],System.Boolean)">
            <summary>
            Writes the array of values of type <typeparamref name="T" /> to the remote process at a specified address.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="address">Address where to write the values to.</param>
            <param name="values">Values to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.ReadString(System.IntPtr,System.Text.Encoding,System.Int32,System.Boolean)">
            <summary>
            Reads a string in the remote process memory.
            </summary>
            <param name="address">Address of the values.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding" /> to use to get the bytes from the string.</param>
            <param name="maxLength">Maximum length of the string(bytes to be read).</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>String at the address.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.ReadString(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Reads a string with a default <see cref="T:System.Text.Encoding" /> in the remote process memory.
            </summary>
            <param name="address">Address of the values.</param>
            <param name="maxLength">Maximum length of the string(bytes to be read).</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>String at the address.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.WriteString(System.IntPtr,System.String,System.Text.Encoding,System.Boolean)">
            <summary>
            Writes a string, using the specified <paramref name="encoding" />, to the remote process at a specified address.
            </summary>
            <param name="address">Address where to write the string to.</param>
            <param name="text">String to write.</param>
            <param name="encoding"><see cref="T:System.Text.Encoding" /> to use to get the bytes from the string.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.WriteString(System.IntPtr,System.String,System.Boolean)">
            <summary>
            Writes a string, using a default <see cref="T:System.Text.Encoding" />, to the remote process at a specified address.
            </summary>
            <param name="address">Address where to write the string to.</param>
            <param name="text">String to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.ReadBytes(System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Reads bytes from the remote process at a specified address.
            </summary>
            <param name="address">Address where to read the bytes from.</param>
            <param name="count">Number of bytes to read.</param>
            <param name="relative">If the address is relative or not.</param>
            <returns>Array of size <paramref name="count" /> with the bytes read.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.WriteBytes(System.IntPtr,System.Byte[],System.Boolean)">
            <summary>
            Writes bytes to the remote process at a specified address.
            </summary>
            <param name="address">Address where to write the bytes to.</param>
            <param name="bytes">Bytes to write.</param>
            <param name="relative">If the address is relative or not.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.ToAbsolute(System.IntPtr)">
            <summary>
            Converts a relative address to an absolute one.
            </summary>
            <param name="address">Relative address.</param>
            <returns>Absolute address</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.GetAddress(System.IntPtr,System.Int32[])">
            <summary>
            Walks a pointer(base + offsets) and returns the final address.
            </summary>
            <param name="address">BaseAddress</param>
            <param name="offsets">Offsets to walk</param>
            <returns>The final address of the pointer.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Alloc(System.Int32,RFReborn.Windows.Native.Enums.MemoryProtection)">
            <summary>
            Allocates memory in the remote process and returns the address of it.
            </summary>
            <param name="size">Size of memory to allocate.</param>
            <param name="protFlags">Protection flags of the newly allocated memory. Default is <see cref="F:RFReborn.Windows.Native.Enums.MemoryProtection.EXECUTE_READWRITE" /></param>
            <returns>The address to the allocated memory.</returns>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Free(System.IntPtr)">
            <summary>
            Frees allocated memory(ex with <see cref="M:RFReborn.Windows.Memory.IRemoteMemory.Alloc(System.Int32,RFReborn.Windows.Native.Enums.MemoryProtection)" />
            </summary>
            <param name="address">Address of the allocated memory to free.</param>
        </member>
        <member name="M:RFReborn.Windows.Memory.RemoteMemory.Dispose">
            <summary>
            Releases all resources used.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.MemoryAllocation">
            <summary>
            The type of memory allocation.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.Commit">
            <summary>
                Allocates memory charges (from the overall size of memory and the paging files on disk) for the specified reserved
                memory pages.
                The function also guarantees that when the caller later initially accesses the memory, the contents will be zero.
                Actual physical pages are not allocated unless/until the virtual addresses are actually accessed.
                To reserve and commit pages in one step, call <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)" /> with MEM_COMMIT |
                MEM_RESERVE.
                The function fails if you attempt to commit a page that has not been reserved. The resulting error code is
                ERROR_INVALID_ADDRESS.
                An attempt to commit a page that is already committed does not cause the function to fail.
                This means that you can commit pages without first determining the current commitment state of each page.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.Reserve">
            <summary>
                Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or
                in the paging file on disk.
                You commit reserved pages by calling <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)" /> again with MEM_COMMIT.
                To reserve and commit pages in one step, call VirtualAllocEx with MEM_COMMIT | MEM_RESERVE.
                Other memory allocation functions, such as malloc and LocalAlloc, cannot use reserved memory until it has been
                released.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.Reset">
            <summary>
                Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest.
                The pages should not be read from or written to the paging file.
                However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with
                any other value.
                Using this value does not guarantee that the range operated on with MEM_RESET will contain zeros. If you want the
                range to contain zeros, decommit the memory and then recommit it.
                When you use MEM_RESET, the VirtualAllocEx function ignores the value of fProtect. However, you must still set
                fProtect to a valid protection value, such as PAGE_NOACCESS.
                <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)" /> returns an error if you use MEM_RESET and the range of memory is mapped to a
                file.
                A shared view is only acceptable if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.TopDown">
            <summary>
                Allocates memory at the highest possible address. This can be slower than regular allocations, especially when
                there are many allocations.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.Physical">
            <summary>
                Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages.
                This value must be used with MEM_RESERVE and no other values.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.ResetUndo">
            <summary>
                MEM_RESET_UNDO should only be called on an address range to which MEM_RESET was successfully applied earlier.
                It indicates that the data in the specified memory range specified by lpAddress and dwSize is of interest to the
                caller and attempts to reverse the effects of MEM_RESET.
                If the function succeeds, that means all data in the specified address range is intact.
                If the function fails, at least some of the data in the address range has been replaced with zeroes.
                This value cannot be used with any other value.
                If MEM_RESET_UNDO is called on an address range which was not MEM_RESET earlier, the behavior is undefined.
                When you specify MEM_RESET, the <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)" /> function ignores the value of flProtect.
                However, you must still set flProtect to a valid protection value, such as PAGE_NOACCESS.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryAllocation.LargePages">
            <summary>
                Allocates memory using large page support.
                The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the
                GetLargePageMinimum function.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.MemoryProtection">
            <summary>
                The following are the memory-protection options; you must specify one of the following values when allocating or
                protecting a page in memory. Protection attributes cannot be assigned to a portion of a page; they can only be
                assigned to a whole page.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.ZeroAccess">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation.
            This value is not officially present in the Microsoft's enumeration but can occur according to the MEMORY_BASIC_INFORMATION structure documentation.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.NOACCESS">
            <summary>
                Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed
                region results in an access violation. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.READONLY">
            <summary>
                Enables read-only access to the committed region of pages. An attempt to write to the committed region results in
                an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region
                results in an access violation.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.READWRITE">
            <summary>
                Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled,
                attempting to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.WRITECOPY">
            <summary>
                Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a
                committed copy-on-write page results in a private copy of the page being made for the process. The private page is
                marked as READWRITE, and the change is written to the new page. If Data Execution Prevention is enabled, attempting
                to execute code in the committed region results in an access violation. This flag is not supported by the
                VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.EXECUTE">
            <summary>
                Enables execute access to the committed region of pages. An attempt to write to the committed region results in an
                access violation. This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.EXECUTE_READ">
            <summary>
                Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region
                results in an access violation. Windows Server 2003 and Windows XP: This attribute is not supported by the
                CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.EXECUTE_READWRITE">
            <summary>
                Enables execute, read-only, or read/write access to the committed region of pages. Windows Server 2003 and Windows
                XP: This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server
                2003 with SP1.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.EXECUTE_WRITECOPY">
            <summary>
                Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write
                to a committed copy-on-write page results in a private copy of the page being made for the process. The private
                page is marked as EXECUTE_READWRITE, and the change is written to the new page. This flag is not supported by the
                VirtualAlloc or VirtualAllocEx functions. Windows Vista, Windows Server 2003 and Windows XP: This attribute is not
                supported by the CreateFileMapping function until Windows Vista with SP1 and Windows Server 2008.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.GUARD">
            <summary>
                Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a
                STATUS_GUARD_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access
                alarm. For more information, see Creating Guard Pages. When an access attempt leads the system to turn off guard
                page status, the underlying page protection takes over. If a guard page exception occurs during a system service,
                the service typically returns a failure status indicator. This value cannot be used with NOACCESS. This flag is not
                supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.NOCACHE">
            <summary>
                Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a
                device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an
                EXCEPTION_ILLEGAL_INSTRUCTION exception. The NOCACHE flag cannot be used with the GUARD, NOACCESS, or WRITECOMBINE
                flags. The NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or
                VirtualAllocExNuma functions. To enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag
                when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.WRITECOMBINE">
            <summary>
                Sets all pages to be write-combined. Applications should not use this attribute except when explicitly required for
                a device. Using the interlocked functions with memory that is mapped as write-combined can result in an
                EXCEPTION_ILLEGAL_INSTRUCTION exception. The WRITECOMBINE flag cannot be specified with the NOACCESS, GUARD, and
                NOCACHE flags. The WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc,
                VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access for shared memory, specify
                the SEC_WRITECOMBINE flag when calling the CreateFileMapping function. Windows Server 2003 and Windows XP: This
                flag is not supported until Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.TARGETS_INVALID">
            <summary>
                Sets all locations in the pages as invalid targets for CFG. Used along with any execute page protection like
                EXECUTE, EXECUTE_READ, EXECUTE_READWRITE and EXECUTE_WRITECOPY. Any indirect call to locations in those pages will
                fail CFG checks and the process will be terminated. The default behavior for executable pages allocated is to be
                marked valid call targets for CFG. This flag is not supported by the VirtualProtect or CreateFileMapping functions.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryProtection.TARGETS_NO_UPDATE">
            <summary>
                Pages in the region will not have their CFG information updated while the protection changes for VirtualProtect.
                For example, if the pages in the region was allocated using TARGETS_INVALID, then the invalid information will be
                maintained while the page protection changes. This flag is only valid when the protection changes to an executable
                type like EXECUTE, EXECUTE_READ, EXECUTE_READWRITE and EXECUTE_WRITECOPY. The default behavior for VirtualProtect
                protection change to executable is to mark all locations as valid call targets for CFG.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.MemoryRelease">
            <summary>
            The type of free operation.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryRelease.Decommit">
            <summary>
                Decommits the specified region of committed pages. After the operation, the pages are in the reserved state.
                The function does not fail if you attempt to decommit an uncommitted page.
                This means that you can decommit a range of pages without first determining their current commitment state.
                Do not use this value with MEM_RELEASE.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryRelease.Release">
            <summary>
                Releases the specified region of pages. After the operation, the pages are in the free state.
                If you specify this value, dwSize must be 0 (zero), and lpAddress must point to the base address returned by the
                VirtualAllocEx function when the region is reserved.
                The function fails if either of these conditions is not met.
                If any pages in the region are committed currently, the function first decommits, and then releases them.
                The function does not fail if you attempt to release pages that are in different states, some reserved and some
                committed.
                This means that you can release a range of pages without first determining the current commitment state.
                Do not use this value with MEM_DECOMMIT.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.MemoryState">
            <summary>
            Memory-state options list.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryState.Commit">
            <summary>
            Indicates committed pages for which physical storage has been allocated, either in memory or in the paging file on disk.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryState.Free">
            <summary>
            Indicates free pages not accessible to the calling process and available to be allocated. 
            For free pages, the information in the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryState.Reserve">
            <summary>
            Indicates reserved pages where a range of the process's virtual address space is reserved without any physical storage being allocated. 
            For reserved pages, the information in the Protect member is undefined.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.MemoryType">
            <summary>
            Memory-type options list.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryType.None">
            <summary>
            This value is not officially present in the Microsoft's enumeration but can occur after testing.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryType.Private">
            <summary>
            Indicates that the memory pages within the region are private (that is, not shared by other processes).
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryType.Mapped">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of a section.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.MemoryType.Image">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of an image section.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.ProcessAccessFlags">
            <summary>
                The Microsoft Windows security model enables you to control access to process objects. For more information about
                security, see Access-Control Model.
                When a user logs in, the system collects a set of data that uniquely identifies the user during the authentication
                process, and stores it in an access token. This access token describes the security context of all processes
                associated with the user. The security context of a process is the set of credentials given to the process or the
                user account that created the process.
                You can use a token to specify the current security context for a process using the CreateProcessWithTokenW
                function. You can specify a security descriptor for a process when you call the CreateProcess, CreateProcessAsUser,
                or CreateProcessWithLogonW function. If you specify NULL, the process gets a default security descriptor. The ACLs
                in the default security descriptor for a process come from the primary or impersonation token of the creator.
                To retrieve a process's security descriptor, call the GetSecurityInfo function. To change a process's security
                descriptor, call the SetSecurityInfo function.
                The valid access rights for process objects include the standard access rights and some process-specific access
                rights. The following table lists the standard access rights used by all objects.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.Terminate">
            <summary>
                Required to terminate a process using TerminateProcess.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.CreateThread">
            <summary>
                Required to create a thread.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.VmOperation">
            <summary>
                Required to perform an operation on the address space of a process (see VirtualProtectEx and WriteProcessMemory).
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.VmRead">
            <summary>
                Required to read memory in a process using ReadProcessMemory.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.VmWrite">
            <summary>
                Required to write to memory in a process using WriteProcessMemory.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.DupHandle">
            <summary>
                Required to duplicate a handle using DuplicateHandle.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.CreateProcess">
            <summary>
                Required to create a process.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.SetQuota">
            <summary>
                Required to set memory limits using SetProcessWorkingSetSize.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.SetInformation">
            <summary>
                Required to set certain information about a process, such as its priority class (see SetPriorityClass).
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.QueryInformation">
            <summary>
                Required to retrieve certain information about a process, such as its token, exit code, and priority class (see
                OpenProcessToken).
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.SuspendResume">
            <summary>
                Required to suspend or resume a process.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.QueryLimitedInformation">
            <summary>
                Required to retrieve certain information about a process (see GetExitCodeProcess, GetPriorityClass, IsProcessInJob,
                QueryFullProcessImageName). A handle that has the PROCESS_QUERY_INFORMATION access right is automatically granted
                PROCESS_QUERY_LIMITED_INFORMATION.
                Windows Server 2003 and Windows XP:  This access right is not supported.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.Synchronize">
            <summary>
                Required to wait for the process to terminate using the wait functions.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.ProcessAccessFlags.AllAccess">
            <summary>
                All possible access rights for a process object. Windows Server 2003 and Windows XP:  The size of the
                PROCESS_ALL_ACCESS flag increased on Windows Server 2008 and Windows Vista. If an application compiled for Windows
                Server 2008 and Windows Vista is run on Windows Server 2003 or Windows XP, the PROCESS_ALL_ACCESS flag is too large
                and the function specifying this flag fails with ERROR_ACCESS_DENIED. To avoid this problem, specify the minimum
                set of access rights required for the operation. If PROCESS_ALL_ACCESS must be used, set _WIN32_WINNT to the
                minimum operating system targeted by your application (for example, #define _WIN32_WINNT _WIN32_WINNT_WINXP). For
                more information, see Using the Windows Headers.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.VirtualKeyCode">
            <summary>
                The list of VirtualKeyCodes (see: http://msdn.microsoft.com/en-us/library/ms645540(VS.85).aspx)
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LBUTTON">
            <summary>
                Left mouse button
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RBUTTON">
            <summary>
                Right mouse button
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.CANCEL">
            <summary>
                Control-break processing
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MBUTTON">
            <summary>
                Middle mouse button (three-button mouse) - NOT contiguous with LBUTTON and RBUTTON
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.XBUTTON1">
            <summary>
                Windows 2000/XP: X1 mouse button - NOT contiguous with LBUTTON and RBUTTON
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.XBUTTON2">
            <summary>
                Windows 2000/XP: X2 mouse button - NOT contiguous with LBUTTON and RBUTTON
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BACK">
            <summary>
                BACKSPACE key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.TAB">
            <summary>
                TAB key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.CLEAR">
            <summary>
                CLEAR key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RETURN">
            <summary>
                ENTER key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SHIFT">
            <summary>
                SHIFT key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.CONTROL">
            <summary>
                CTRL key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MENU">
            <summary>
                ALT key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PAUSE">
            <summary>
                PAUSE key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.CAPITAL">
            <summary>
                CAPS LOCK key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.KANA">
            <summary>
                Input Method Editor (IME) Kana mode
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.HANGEUL">
            <summary>
                IME Hanguel mode (maintained for compatibility; use HANGUL)
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.HANGUL">
            <summary>
                IME Hangul mode
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.JUNJA">
            <summary>
                IME Junja mode
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.FINAL">
            <summary>
                IME final mode
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.HANJA">
            <summary>
                IME Hanja mode
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.KANJI">
            <summary>
                IME Kanji mode
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.ESCAPE">
            <summary>
                ESC key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.CONVERT">
            <summary>
                IME convert
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NONCONVERT">
            <summary>
                IME nonconvert
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.ACCEPT">
            <summary>
                IME accept
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MODECHANGE">
            <summary>
                IME mode change request
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SPACE">
            <summary>
                SPACEBAR
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PRIOR">
            <summary>
                PAGE UP key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NEXT">
            <summary>
                PAGE DOWN key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.END">
            <summary>
                END key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.HOME">
            <summary>
                HOME key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LEFT">
            <summary>
                LEFT ARROW key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.UP">
            <summary>
                UP ARROW key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RIGHT">
            <summary>
                RIGHT ARROW key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.DOWN">
            <summary>
                DOWN ARROW key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SELECT">
            <summary>
                SELECT key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PRINT">
            <summary>
                PRINT key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.EXECUTE">
            <summary>
                EXECUTE key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SNAPSHOT">
            <summary>
                PRINT SCREEN key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.INSERT">
            <summary>
                INS key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.DELETE">
            <summary>
                DEL key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.HELP">
            <summary>
                HELP key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_0">
            <summary>
                0 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_1">
            <summary>
                1 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_2">
            <summary>
                2 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_3">
            <summary>
                3 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_4">
            <summary>
                4 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_5">
            <summary>
                5 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_6">
            <summary>
                6 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_7">
            <summary>
                7 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_8">
            <summary>
                8 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_9">
            <summary>
                9 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_A">
            <summary>
                A key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_B">
            <summary>
                B key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_C">
            <summary>
                C key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_D">
            <summary>
                D key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_E">
            <summary>
                E key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_F">
            <summary>
                F key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_G">
            <summary>
                G key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_H">
            <summary>
                H key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_I">
            <summary>
                I key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_J">
            <summary>
                J key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_K">
            <summary>
                K key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_L">
            <summary>
                L key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_M">
            <summary>
                M key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_N">
            <summary>
                N key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_O">
            <summary>
                O key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_P">
            <summary>
                P key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_Q">
            <summary>
                Q key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_R">
            <summary>
                R key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_S">
            <summary>
                S key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_T">
            <summary>
                T key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_U">
            <summary>
                U key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_V">
            <summary>
                V key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_W">
            <summary>
                W key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_X">
            <summary>
                X key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_Y">
            <summary>
                Y key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VK_Z">
            <summary>
                Z key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LWIN">
            <summary>
                Left Windows key (Microsoft Natural keyboard)
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RWIN">
            <summary>
                Right Windows key (Natural keyboard)
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.APPS">
            <summary>
                Applications key (Natural keyboard)
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SLEEP">
            <summary>
                Computer Sleep key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD0">
            <summary>
                Numeric keypad 0 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD1">
            <summary>
                Numeric keypad 1 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD2">
            <summary>
                Numeric keypad 2 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD3">
            <summary>
                Numeric keypad 3 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD4">
            <summary>
                Numeric keypad 4 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD5">
            <summary>
                Numeric keypad 5 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD6">
            <summary>
                Numeric keypad 6 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD7">
            <summary>
                Numeric keypad 7 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD8">
            <summary>
                Numeric keypad 8 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMPAD9">
            <summary>
                Numeric keypad 9 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MULTIPLY">
            <summary>
                Multiply key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.ADD">
            <summary>
                Add key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SEPARATOR">
            <summary>
                Separator key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SUBTRACT">
            <summary>
                Subtract key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.DECIMAL">
            <summary>
                Decimal key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.DIVIDE">
            <summary>
                Divide key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F1">
            <summary>
                F1 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F2">
            <summary>
                F2 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F3">
            <summary>
                F3 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F4">
            <summary>
                F4 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F5">
            <summary>
                F5 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F6">
            <summary>
                F6 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F7">
            <summary>
                F7 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F8">
            <summary>
                F8 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F9">
            <summary>
                F9 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F10">
            <summary>
                F10 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F11">
            <summary>
                F11 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F12">
            <summary>
                F12 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F13">
            <summary>
                F13 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F14">
            <summary>
                F14 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F15">
            <summary>
                F15 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F16">
            <summary>
                F16 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F17">
            <summary>
                F17 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F18">
            <summary>
                F18 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F19">
            <summary>
                F19 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F20">
            <summary>
                F20 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F21">
            <summary>
                F21 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F22">
            <summary>
                F22 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F23">
            <summary>
                F23 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.F24">
            <summary>
                F24 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NUMLOCK">
            <summary>
                NUM LOCK key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.SCROLL">
            <summary>
                SCROLL LOCK key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LSHIFT">
            <summary>
                Left SHIFT key - Used only as parameters to GetAsyncKeyState() and GetKeyState()
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RSHIFT">
            <summary>
                Right SHIFT key - Used only as parameters to GetAsyncKeyState() and GetKeyState()
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LCONTROL">
            <summary>
                Left CONTROL key - Used only as parameters to GetAsyncKeyState() and GetKeyState()
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RCONTROL">
            <summary>
                Right CONTROL key - Used only as parameters to GetAsyncKeyState() and GetKeyState()
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LMENU">
            <summary>
                Left MENU key - Used only as parameters to GetAsyncKeyState() and GetKeyState()
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.RMENU">
            <summary>
                Right MENU key - Used only as parameters to GetAsyncKeyState() and GetKeyState()
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_BACK">
            <summary>
                Windows 2000/XP: Browser Back key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_FORWARD">
            <summary>
                Windows 2000/XP: Browser Forward key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_REFRESH">
            <summary>
                Windows 2000/XP: Browser Refresh key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_STOP">
            <summary>
                Windows 2000/XP: Browser Stop key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_SEARCH">
            <summary>
                Windows 2000/XP: Browser Search key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_FAVORITES">
            <summary>
                Windows 2000/XP: Browser Favorites key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.BROWSER_HOME">
            <summary>
                Windows 2000/XP: Browser Start and Home key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VOLUME_MUTE">
            <summary>
                Windows 2000/XP: Volume Mute key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VOLUME_DOWN">
            <summary>
                Windows 2000/XP: Volume Down key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.VOLUME_UP">
            <summary>
                Windows 2000/XP: Volume Up key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MEDIA_NEXT_TRACK">
            <summary>
                Windows 2000/XP: Next Track key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MEDIA_PREV_TRACK">
            <summary>
                Windows 2000/XP: Previous Track key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MEDIA_STOP">
            <summary>
                Windows 2000/XP: Stop Media key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.MEDIA_PLAY_PAUSE">
            <summary>
                Windows 2000/XP: Play/Pause Media key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LAUNCH_MAIL">
            <summary>
                Windows 2000/XP: Start Mail key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LAUNCH_MEDIA_SELECT">
            <summary>
                Windows 2000/XP: Select Media key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LAUNCH_APP1">
            <summary>
                Windows 2000/XP: Start Application 1 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.LAUNCH_APP2">
            <summary>
                Windows 2000/XP: Start Application 2 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_1">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the ';:'
                key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_PLUS">
            <summary>
                Windows 2000/XP: For any country/region, the '+' key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_COMMA">
            <summary>
                Windows 2000/XP: For any country/region, the ',' key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_MINUS">
            <summary>
                Windows 2000/XP: For any country/region, the '-' key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_PERIOD">
            <summary>
                Windows 2000/XP: For any country/region, the '.' key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_2">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the '/?'
                key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_3">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the '`~'
                key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_4">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the '[{'
                key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_5">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the '\|'
                key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_6">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the ']}'
                key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_7">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard. Windows 2000/XP: For the US standard keyboard, the
                'single-quote/double-quote' key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_8">
            <summary>
                Used for miscellaneous characters; it can vary by keyboard.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_102">
            <summary>
                Windows 2000/XP: Either the angle bracket key or the backslash key on the RT 102-key keyboard
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PROCESSKEY">
            <summary>
                Windows 95/98/Me, Windows NT 4.0, Windows 2000/XP: IME PROCESS key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PACKET">
            <summary>
                Windows 2000/XP: Used to pass Unicode characters as if they were keystrokes. The PACKET key is the low word of a
                32-bit Virtual Key value used for non-keyboard input methods. For more information, see Remark in KEYBDINPUT,
                SendInput, WM_KEYDOWN, and WM_KEYUP
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.ATTN">
            <summary>
                Attn key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.CRSEL">
            <summary>
                CrSel key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.EXSEL">
            <summary>
                ExSel key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.EREOF">
            <summary>
                Erase EOF key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PLAY">
            <summary>
                Play key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.ZOOM">
            <summary>
                Zoom key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.NONAME">
            <summary>
                Reserved
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.PA1">
            <summary>
                PA1 key
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.VirtualKeyCode.OEM_CLEAR">
            <summary>
                Clear key
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Enums.WindowsMessage">
            <summary>
                Windows Messages
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_KEYDOWN">
            <summary>
            Posted to the window with the keyboard focus when a nonsystem key is pressed.
            A nonsystem key is a key that is pressed when the ALT key is not pressed.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_KEYUP">
            <summary>
            Posted to the window with the keyboard focus when a nonsystem key is released.
            A nonsystem key is a key that is pressed when the ALT key is not pressed, or a keyboard key that is pressed when a window has the keyboard focus.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_MOUSEMOVE">
            <summary>
            Posted to a window when the cursor moves. If the mouse is not captured, the message is posted to the window that contains the cursor.
            Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_LBUTTONDOWN">
            <summary>
            Posted when the user presses the left mouse button while the cursor is in the client area of a window.
            If the mouse is not captured, the message is posted to the window beneath the cursor.
            Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_LBUTTONUP">
            <summary>
            Posted when the user releases the left mouse button while the cursor is in the client area of a window.
            If the mouse is not captured, the message is posted to the window beneath the cursor.
            Otherwise, the message is posted to the window that has captured the mouse
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_LBUTTONDBLCLK">
            <summary>
            Posted when the user double-clicks the left mouse button while the cursor is in the client area of a window.
            If the mouse is not captured, the message is posted to the window beneath the cursor.
            Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_RBUTTONDOWN">
            <summary>
            Posted when the user presses the right mouse button while the cursor is in the client area of a window.
            If the mouse is not captured, the message is posted to the window beneath the cursor.
            Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_RBUTTONUP">
            <summary>
            Posted when the user releases the right mouse button while the cursor is in the client area of a window.
            If the mouse is not captured, the message is posted to the window beneath the cursor.
            Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_RBUTTONDBLCLK">
            <summary>
            Posted when the user double-clicks the right mouse button while the cursor is in the client area of a window.
            If the mouse is not captured, the message is posted to the window beneath the cursor.
            Otherwise, the message is posted to the window that has captured the mouse.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Enums.WindowsMessage.WM_MOUSEWHEEL">
            <summary>
            Sent to the focus window when the mouse wheel is rotated. The DefWindowProc function propagates the message to the window's parent.
            There should be no internal forwarding of the message, since DefWindowProc propagates it up the parent chain until it finds a window that processes it.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.Handle">
            <summary>
            Win32 SafeHandle
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Native.Handle.#ctor">
            <summary>
            Paramterless constructor for handles built by <see cref="M:RFReborn.Windows.Native.Kernel32.OpenProcess(RFReborn.Windows.Native.Enums.ProcessAccessFlags,System.Boolean,System.Int32)"/>
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Native.Handle.#ctor(System.IntPtr)">
            <summary>
            Initializes a new handle with the handle as <see cref="T:System.IntPtr"/>
            </summary>
            <param name="handle"></param>
        </member>
        <member name="M:RFReborn.Windows.Native.Handle.ReleaseHandle">
            <summary>
            Closes the handle with <see cref="M:RFReborn.Windows.Native.Kernel32.CloseHandle(System.IntPtr)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:RFReborn.Windows.Native.Kernel32">
            <summary>
            Methods from the Kernel32.dll
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.CloseHandle(System.IntPtr)">
            <summary>
                Closes an open object handle.
            </summary>
            <param name="hObject">
                A valid handle to an open object.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.To get
                extended error information, call GetLastError. If the application is running under a debugger, the function will
                throw an exception if it receives either a handle value that is not valid or a pseudo-handle value. This can happen
                if you close a handle twice, or if you call CloseHandle on a handle returned by the FindFirstFile function instead
                of calling the FindClose function.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.VirtualProtectEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryProtection,RFReborn.Windows.Native.Enums.MemoryProtection@)">
            <summary>
                Changes the protection on a region of committed pages in the virtual address space of a specified process.
            </summary>
            <param name="hProcess">
                A handle to the process whose memory protection is to be changed. The handle must have the PROCESS_VM_OPERATION
                access right.
            </param>
            <param name="lpAddress">
                A pointer to the base address of the region of pages whose access protection attributes are to be changed. All
                pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or
                VirtualAllocEx function using MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by
                separate calls to VirtualAlloc or VirtualAllocEx using MEM_RESERVE.
            </param>
            <param name="dwSize">
                The size of the region whose access protection attributes are changed, in bytes. The region of affected pages
                includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize).
                This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be
                changed.
            </param>
            <param name="flNewProtect">
                The memory protection option. This parameter can be one of the memory protection constants. For mapped views, this
                value must be compatible with the access protection specified when the view was mapped(see MapViewOfFile,
                MapViewOfFileEx, and MapViewOfFileExNuma).
            </param>
            <param name="lpflOldProtect">
                A pointer to a variable that receives the previous access protection of the first page in the specified region of
                pages. If this parameter is NULL or does not point to a valid variable, the function fails.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get
                extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.VirtualQueryEx(RFReborn.Windows.Native.Handle,System.IntPtr,RFReborn.Windows.Native.Structs.MemoryBasicInformation@,System.Int32)">
            <summary>
            Retrieves information about a range of pages within the virtual address space of a specified process.
            </summary>
            <param name="hProcess">
            A handle to the process whose memory information is queried. 
            The handle must have been opened with the PROCESS_QUERY_INFORMATION access right, which enables using the handle to read information from the process object. 
            For more information, see Process Security and Access Rights.
            </param>
            <param name="lpAddress">
            A pointer to the base address of the region of pages to be queried. 
            This value is rounded down to the next page boundary. 
            To determine the size of a page on the host computer, use the GetSystemInfo function. 
            If lpAddress specifies an address above the highest memory address accessible to the process, the function fails with ERROR_INVALID_PARAMETER.
            </param>
            <param name="lpBuffer">[Out] A pointer to a <see cref="T:RFReborn.Windows.Native.Structs.MemoryBasicInformation"/> structure in which information about the specified page range is returned.</param>
            <param name="dwLength">The size of the buffer pointed to by the lpBuffer parameter, in bytes.</param>
            <returns>
            The return value is the actual number of bytes returned in the information buffer. 
            If the function fails, the return value is zero. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)">
            <summary>
            Reserves or commits a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero, unless MEM_RESET is used.
            To specify the NUMA node for the physical memory, see VirtualAllocExNuma.
            </summary>
            <param name="hProcess">
            The handle to a process. The function allocates memory within the virtual address space of this process. 
            The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.
            </param>
            <param name="lpAddress">
            The pointer that specifies a desired starting address for the region of pages that you want to allocate. 
            If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity. 
            If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. 
            To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function.
            </param>
            <param name="dwSize">
            The size of the region of memory to allocate, in bytes. 
            If lpAddress is NULL, the function rounds dwSize up to the next page boundary. 
            If lpAddress is not NULL, the function allocates all pages that contain one or more bytes in the range from lpAddress to lpAddress+dwSize. 
            This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.
            </param>
            <param name="flAllocationType">[Flags] The type of memory allocation.</param>
            <param name="flProtect">[Flags] The memory protection for the region of pages to be allocated.</param>
            <returns>
            If the function succeeds, the return value is the base address of the allocated region of pages. 
            If the function fails, the return value is NULL. To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.VirtualFreeEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryRelease)">
            <summary>
            Releases, decommits, or releases and decommits a region of memory within the virtual address space of a specified process.
            </summary>
            <param name="hProcess">A handle to a process. The function frees memory within the virtual address space of the process. 
            The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.
            </param>
            <param name="lpAddress">
            A pointer to the starting address of the region of memory to be freed. 
            If the dwFreeType parameter is MEM_RELEASE, lpAddress must be the base address returned by the <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)"/> function when the region is reserved.
            </param>
            <param name="dwSize">
            The size of the region of memory to free, in bytes. 
            If the dwFreeType parameter is MEM_RELEASE, dwSize must be 0 (zero). 
            The function frees the entire region that is reserved in the initial allocation call to <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)"/>. 
            If dwFreeType is MEM_DECOMMIT, the function decommits all memory pages that contain one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). 
            This means, for example, that a 2-byte region of memory that straddles a page boundary causes both pages to be decommitted. 
            If lpAddress is the base address returned by VirtualAllocEx and dwSize is 0 (zero), the function decommits the entire region that is allocated by <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualAllocEx(RFReborn.Windows.Native.Handle,System.IntPtr,System.Int32,RFReborn.Windows.Native.Enums.MemoryAllocation,RFReborn.Windows.Native.Enums.MemoryProtection)"/>. 
            After that, the entire region is in the reserved state.
            </param>
            <param name="dwFreeType">[Flags] The type of free operation.</param>
            <returns>
            If the function succeeds, the return value is a nonzero value. 
            If the function fails, the return value is 0 (zero). To get extended error information, call <see cref="M:System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.OpenProcess(RFReborn.Windows.Native.Enums.ProcessAccessFlags,System.Boolean,System.Int32)">
            <summary>
                Opens an existing local process object.
            </summary>
            <param name="dwDesiredAccess">
                The access to the process object. This access right is checked against the security descriptor for the process.
                This parameter can be one or more of the process access rights. If the caller has enabled the SeDebugPrivilege
                privilege, the requested access is granted regardless of the contents of the security descriptor.
            </param>
            <param name="bInheritHandle">
                If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not
                inherit this handle.
            </param>
            <param name="dwProcessId">
                The identifier of the local process to be opened. If the specified process is the System Process(0x00000000), the
                function fails and the last error code is ERROR_INVALID_PARAMETER.If the specified process is the Idle process or
                one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access
                restrictions prevent user-level code from opening them. If you are using GetCurrentProcessId as an argument to this
                function, consider using GetCurrentProcess instead of OpenProcess, for improved performance.
            </param>
            <returns>
                If the function succeeds, the return value is an open handle to the specified process. If the function fails, the
                return value is NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.ReadProcessMemory(RFReborn.Windows.Native.Handle,System.IntPtr,System.Byte[],System.Int32,System.Int32@)">
            <summary>
                Reads data from an area of memory in a specified process. The entire area to be read must be accessible or the
                operation fails.
            </summary>
            <param name="hProcess">
                A handle to the process with memory that is being read. The handle must have PROCESS_VM_READ access to the process.
            </param>
            <param name="lpBaseAddress">
                A pointer to the base address in the specified process from which to read. Before any data transfer occurs, the
                system verifies that all data in the base address and memory of the specified size is accessible for read access,
                and if it is not accessible the function fails.
            </param>
            <param name="lpBuffer">
                A pointer to a buffer that receives the contents from the address space of the specified process.
            </param>
            <param name="nSize">
                The number of bytes to be read from the specified process.
            </param>
            <param name="lpNumberOfBytesRead">
                A pointer to a variable that receives the number of bytes transferred into the specified buffer. If
                lpNumberOfBytesRead is NULL, the parameter is ignored.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To
                get extended error information, call GetLastError. The function fails if the requested read operation crosses into
                an area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.WriteProcessMemory(RFReborn.Windows.Native.Handle,System.IntPtr,System.Byte[],System.Int32,System.Int32@)">
            <summary>
                Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the
                operation fails.
            </summary>
            <param name="hProcess">
                A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION
                access to the process.
            </param>
            <param name="lpBaseAddress">
                A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the
                system verifies that all data in the base address and memory of the specified size is accessible for write access,
                and if it is not accessible, the function fails.
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that contains data to be written in the address space of the specified process.
            </param>
            <param name="nSize">
                The number of bytes to be written to the specified process.
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is
                optional. If lpNumberOfBytesWritten is NULL, the parameter is ignored.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get
                extended error information, call GetLastError.The function fails if the requested write operation crosses into an
                area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.WriteProcessMemory(RFReborn.Windows.Native.Handle,System.IntPtr,System.Void*,System.Int32,System.Int32@)">
            <summary>
                Writes data to an area of memory in a specified process. The entire area to be written to must be accessible or the
                operation fails.
            </summary>
            <param name="hProcess">
                A handle to the process memory to be modified. The handle must have PROCESS_VM_WRITE and PROCESS_VM_OPERATION
                access to the process.
            </param>
            <param name="lpBaseAddress">
                A pointer to the base address in the specified process to which data is written. Before data transfer occurs, the
                system verifies that all data in the base address and memory of the specified size is accessible for write access,
                and if it is not accessible, the function fails.
            </param>
            <param name="lpBuffer">
                A pointer to the buffer that contains data to be written in the address space of the specified process.
            </param>
            <param name="nSize">
                The number of bytes to be written to the specified process.
            </param>
            <param name="lpNumberOfBytesWritten">
                A pointer to a variable that receives the number of bytes transferred into the specified process. This parameter is
                optional. If lpNumberOfBytesWritten is NULL, the parameter is ignored.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero. If the function fails, the return value is 0 (zero). To get
                extended error information, call GetLastError.The function fails if the requested write operation crosses into an
                area of the process that is inaccessible.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.Kernel32.IsWow64Process(System.IntPtr,System.Boolean@)">
            <summary>
                Determines whether the specified process is running under WOW64.
            </summary>
            <param name="hProcess">
                A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
                access right. For more information, see Process Security and Access Rights. Windows Server 2003 and Windows XP:
                The handle must have the PROCESS_QUERY_INFORMATION access right.
            </param>
            <param name="wow64Process">
                A pointer to a value that is set to TRUE if the process is running under WOW64. If the process is running under
                32-bit Windows, the value is set to FALSE. If the process is a 64-bit application running under 64-bit Windows, the
                value is also set to FALSE.
            </param>
            <returns>
                If the function succeeds, the return value is a nonzero value. If the function fails, the return value is zero.To
                get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="T:RFReborn.Windows.Native.Structs.MemoryBasicInformation">
            <summary>
            Contains information about a range of pages in the virtual address space of a process. The VirtualQuery and <see cref="M:RFReborn.Windows.Native.Kernel32.VirtualQueryEx(RFReborn.Windows.Native.Handle,System.IntPtr,RFReborn.Windows.Native.Structs.MemoryBasicInformation@,System.Int32)"/> functions use this structure.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.BaseAddress">
            <summary>
            A pointer to the base address of the region of pages.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.AllocationBase">
            <summary>
            A pointer to the base address of a range of pages allocated by the VirtualAlloc function. The page pointed to by the BaseAddress member is contained within this allocation range.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.AllocationProtect">
            <summary>
            The memory protection option when the region was initially allocated. This member can be one of the memory protection constants or 0 if the caller does not have access.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.RegionSize">
            <summary>
            The size of the region beginning at the base address in which all pages have identical attributes, in bytes.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.State">
            <summary>
            The state of the pages in the region.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.Protect">
            <summary>
            The access protection of the pages in the region. This member is one of the values listed for the AllocationProtect member.
            </summary>
        </member>
        <member name="F:RFReborn.Windows.Native.Structs.MemoryBasicInformation.Type">
            <summary>
            The type of pages in the region.
            </summary>
        </member>
        <member name="T:RFReborn.Windows.Native.User32">
            <summary>
            Methods from the User32.dll
            </summary>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.SendMessage(System.IntPtr,System.Int32,System.UInt32,System.UInt32)">
            <summary>
                Sends the specified message to a window or windows. The SendMessage function calls the window procedure for the
                specified window and does not return until the window procedure has processed the message.
                To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function.To post a
                message to a thread's message queue and return immediately, use the PostMessage or PostThreadMessage function.
            </summary>
            <param name="hWnd">
                A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST
                ((HWND)0xffff), the message is sent to all top-level windows in the system, including disabled or invisible unowned
                windows, overlapped windows, and pop-up windows; but the message is not sent to child windows.
                Message sending is subject to UIPI.
                The thread of a process can send messages only to message queues of threads in
                processes of lesser or equal integrity level.
            </param>
            <param name="uMsg">
                The message to be sent.
            </param>
            <param name="wParam">
                Additional message-specific information.
            </param>
            <param name="lParam">
                Additional message-specific information.
            </param>
            <returns>
                The return value specifies the result of the message processing; it depends on the message sent.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.VkKeyScan(System.Char)">
            <summary>
                Translates a character to the corresponding virtual-key code and shift state for the current keyboard.
            </summary>
            <param name="ch">
                The character to be translated into a virtual-key code.
            </param>
            <returns>
                If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order
                byte contains the shift state, which can be a combination of the following flag bits.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.MapVirtualKey(System.UInt32,System.UInt32)">
            <summary>
                Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a
                virtual-key code.
                To specify a handle to the keyboard layout to use for translating the specified code, use the MapVirtualKeyEx
                function.
            </summary>
            <param name="uCode">
                The virtual key code or scan code for a key. How this value is interpreted depends on the value of the uMapType
                parameter.
            </param>
            <param name="uMapType">
                The translation to be performed. The value of this parameter depends on the value of the uCode parameter.
            </param>
            <returns>
                The return value is either a scan code, a virtual-key code, or a character value, depending on the value of uCode
                and uMapType. If there is no translation, the return value is zero.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.PostMessage(System.IntPtr,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
                Places (posts) a message in the message queue associated with the thread that created the specified window and
                returns without waiting for the thread to process the message.
                To post a message in the message queue associated with a thread, use the PostThreadMessage function.
            </summary>
            <param name="hWnd">
                A handle to the window whose window procedure is to receive the message. The following values have special
                meanings.
                HWND_BROADCAST ((HWND)0xffff): The message is posted to all top-level windows in the system, including disabled or
                invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.
                NULL: The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of
                the current thread.
            </param>
            <param name="msg">
                The message to be posted.
            </param>
            <param name="wParam">
                Additional message-specific information.
            </param>
            <param name="lParam">
                Additional message-specific information.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                If the function fails, the return value is zero.To get extended error information, call GetLastError.GetLastError
                returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.PostMessage(System.IntPtr,System.UInt32,System.UInt64,System.UInt32)">
            <summary>
                Places (posts) a message in the message queue associated with the thread that created the specified window and
                returns without waiting for the thread to process the message.
                To post a message in the message queue associated with a thread, use the PostThreadMessage function.
            </summary>
            <param name="hWnd">
                A handle to the window whose window procedure is to receive the message. The following values have special
                meanings.
                HWND_BROADCAST ((HWND)0xffff): The message is posted to all top-level windows in the system, including disabled or
                invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.
                NULL: The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of
                the current thread.
            </param>
            <param name="msg">
                The message to be posted.
            </param>
            <param name="wParam">
                Additional message-specific information.
            </param>
            <param name="lParam">
                Additional message-specific information.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                If the function fails, the return value is zero.To get extended error information, call GetLastError.GetLastError
                returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.PostMessage(System.IntPtr,RFReborn.Windows.Native.Enums.WindowsMessage,System.UInt32,System.UInt32)">
            <summary>
                Places (posts) a message in the message queue associated with the thread that created the specified window and
                returns without waiting for the thread to process the message.
                To post a message in the message queue associated with a thread, use the PostThreadMessage function.
            </summary>
            <param name="hWnd">
                A handle to the window whose window procedure is to receive the message. The following values have special
                meanings.
                HWND_BROADCAST ((HWND)0xffff): The message is posted to all top-level windows in the system, including disabled or
                invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.
                NULL: The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of
                the current thread.
            </param>
            <param name="msg">
                The message to be posted.
            </param>
            <param name="wParam">
                Additional message-specific information.
            </param>
            <param name="lParam">
                Additional message-specific information.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                If the function fails, the return value is zero.To get extended error information, call GetLastError.GetLastError
                returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.Native.User32.PostMessage(System.IntPtr,RFReborn.Windows.Native.Enums.WindowsMessage,System.UInt64,System.UInt32)">
            <summary>
                Places (posts) a message in the message queue associated with the thread that created the specified window and
                returns without waiting for the thread to process the message.
                To post a message in the message queue associated with a thread, use the PostThreadMessage function.
            </summary>
            <param name="hWnd">
                A handle to the window whose window procedure is to receive the message. The following values have special
                meanings.
                HWND_BROADCAST ((HWND)0xffff): The message is posted to all top-level windows in the system, including disabled or
                invisible unowned windows, overlapped windows, and pop-up windows. The message is not posted to child windows.
                NULL: The function behaves like a call to PostThreadMessage with the dwThreadId parameter set to the identifier of
                the current thread.
            </param>
            <param name="msg">
                The message to be posted.
            </param>
            <param name="wParam">
                Additional message-specific information.
            </param>
            <param name="lParam">
                Additional message-specific information.
            </param>
            <returns>
                If the function succeeds, the return value is nonzero.
                If the function fails, the return value is zero.To get extended error information, call GetLastError.GetLastError
                returns ERROR_NOT_ENOUGH_QUOTA when the limit is hit.
            </returns>
        </member>
        <member name="T:RFReborn.Windows.ProcessHelpers">
            <summary>
            Adds various methods to interact with <see cref="T:System.Diagnostics.Process"/>
            </summary>
        </member>
        <member name="M:RFReborn.Windows.ProcessHelpers.OpenProcess(RFReborn.Windows.Native.Enums.ProcessAccessFlags,System.Int32)">
            <summary>
                Opens an existing local process object.
            </summary>
            <param name="accessFlags">
                The access to the process object. This access right is checked against the security descriptor for the process.
                This parameter can be one or more of the process access rights. If the caller has enabled the SeDebugPrivilege
                privilege, the requested access is granted regardless of the contents of the security descriptor.
            </param>
            <param name="procId">
                The identifier of the local process to be opened. If the specified process is the System Process(0x00000000), the
                function fails and the last error code is ERROR_INVALID_PARAMETER.If the specified process is the Idle process or
                one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access
                restrictions prevent user-level code from opening them. If you are using GetCurrentProcessId as an argument to this
                function, consider using GetCurrentProcess instead of OpenProcess, for improved performance.
            </param>
            <returns>
                If the function succeeds, the return value is an open handle to the specified process. If the function fails, the
                return value is NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.ProcessHelpers.OpenProcess(RFReborn.Windows.Native.Enums.ProcessAccessFlags,System.Diagnostics.Process)">
            <summary>
                Opens an existing local process object.
            </summary>
            <param name="accessFlags">
                The access to the process object. This access right is checked against the security descriptor for the process.
                This parameter can be one or more of the process access rights. If the caller has enabled the SeDebugPrivilege
                privilege, the requested access is granted regardless of the contents of the security descriptor.
            </param>
            <param name="proc">
                The identifier of the local process to be opened. If the specified process is the System Process(0x00000000), the
                function fails and the last error code is ERROR_INVALID_PARAMETER.If the specified process is the Idle process or
                one of the CSRSS processes, this function fails and the last error code is ERROR_ACCESS_DENIED because their access
                restrictions prevent user-level code from opening them. If you are using GetCurrentProcessId as an argument to this
                function, consider using GetCurrentProcess instead of OpenProcess, for improved performance.
            </param>
            <returns>
                If the function succeeds, the return value is an open handle to the specified process. If the function fails, the
                return value is NULL.To get extended error information, call GetLastError.
            </returns>
        </member>
        <member name="M:RFReborn.Windows.ProcessHelpers.Is64Bit(System.Diagnostics.Process)">
            <summary>
            Determines whether the specified process is 64bit or not.
            </summary>
            <param name="proc">The process to check.</param>
            <returns><see langword="true"/> if 64bit, otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:RFReborn.Windows.ProcessHelpers.ProcessExists(System.Diagnostics.Process)">
            <summary>
            Determines whether the specified process exists.
            </summary>
            <param name="process">The process to check.</param>
            <returns><see langword="true"/> if process exists, otherwise <see langword="false"/>.</returns>
        </member>
    </members>
</doc>
